/*
 * simile_prolog.jj
 *
 * Author:	Gary W. Johnson, Jr. (sp4rt4n)
 * Date:	May 27, 2007
 *
 * Purpose:	The lexer and parser defined here are meant
 *			to read in dynamic model specification files
 *			exported by a modeling application called Simile.
 *			These are text files written in a dialect of
 *			Prolog.  Once parsed, the model definition
 *			should be stored as a collection of Java objects
 *			to then be translated into any output format
 *			the user desires.  Here these objects are
 *			subclassed from the JUNG 1.7.6 library so as to
 *			represent the model as a Directed Graph containing
 *			a collection of Vertices connected by Directed Edges.
 *
 */

/* Override javacc Default Options */
options {
	STATIC = false;
}

/*
 * Define the Parser's main and helper classes
 *	- currently the parser reads from STDIN and writes to STDOUT
 */
PARSER_BEGIN(SimilePrologReader)
	package org.integratedmodelling.dynamicmodelling.simile;
	
	import javax.swing.tree.DefaultMutableTreeNode;
	import org.integratedmodelling.dynamicmodelling.model.*;
	import edu.uci.ics.jung.graph.impl.SimpleDirectedSparseVertex;
	import java.util.Vector;
	import java.util.Hashtable;
	import java.util.Enumeration;
	
	public class SimilePrologReader {
		// These are populated during the parsing phase and used
		// to construct the models during the build phase.
		private Hashtable<String, SimilePrologExpression> metadata = new Hashtable<String, SimilePrologExpression>();
		private Hashtable<String, Node> nodeList = new Hashtable<String, Node>();
		private Hashtable<String, Arc> arcList = new Hashtable<String, Arc>();
		private Hashtable<String, Links> linksList = new Hashtable<String, Links>();

		// These are used to maintain internal references during
		// the model build phase.
		private Hashtable<String, Stock> stockList = new Hashtable<String, Stock>();
		private Hashtable<String, Flow> flowList = new Hashtable<String, Flow>();
		private Hashtable<String, Variable> variableList = new Hashtable<String, Variable>();
		private Hashtable<String, Submodel> submodelList = new Hashtable<String, Submodel>();

		// fv formula node to make parsing trees out of formulas.
		public static class FormulaNode extends DefaultMutableTreeNode {
			
			public enum NodeType {
				IF,
				OPERATOR,
				FUNCTION,
				NUMBERLITERAL,
				STRINGLITERAL,
				VARIABLE,
				EXPRESSION,
				LIST
			}
			
			NodeType nodeType;
			
			/*
			 * for compatibility with Gary's code - just accumulate the characters here for
			 * now. The toString method of this one returns the text. 
			 */
			String formulaText = "";
			String operator = null;
			String function = null;
			String literal = null;
			
			public String toString() {
				return formulaText;
			}
		}

		public static void main(String[] args) throws ParseException, TokenMgrError {
			SimilePrologReader parser = new SimilePrologReader(System.in);
			Model topLevelModel = parser.generateModel();
			if (topLevelModel.getName() != null) {
				System.out.println("The Simile model was recreated successfully.");
			}
		}
	
		public static String textValue(Object o) {
			return o == null ? "" : o.toString();
		}
	
		public Model generateModel() throws ParseException, TokenMgrError {
			this.Start();
			Model topLevelModel = new Model();
			if (metadata.containsKey("source") && metadata.containsKey("roots") && metadata.containsKey("properties")) {
				Vector<String> topLevelModelNodes = ((Roots) metadata.get("roots")).subnodes;
				Hashtable<String, Object> topLevelModelProperties = ((Properties) metadata.get("properties")).properties;
				topLevelModel = buildModelFromNodes("topLevelModel", topLevelModelNodes, topLevelModelProperties);
				addArcsToModel();
			} else {
				System.out.println("File did not contain a complete Simile model specification.  Cannot build models.");
			}
			return topLevelModel;
		}

		private Model buildModelFromNodes(String modelNodeID, Vector<String> modelNodes, Hashtable<String, Object> modelProperties) {
			System.out.println("Building model with nodeID " + modelNodeID + "...");

			// Create the new Model object and set its properties
			Model thisModel = new Model();

			thisModel.setName(modelProperties.get("name").toString());
			thisModel.setProgram(((Source) metadata.get("source")).program);
			thisModel.setVersion(((Source) metadata.get("source")).version);
			thisModel.setEdition(((Source) metadata.get("source")).edition);
			thisModel.setDate(((Source) metadata.get("source")).date);

			// Loop through the list of modelNodes and...
			// 1) Add submodels to thisModel as Model objects wrapped in Submodels
			// 2) Add compartments to thisModel as Stocks
			// 3) Add variables/conditions to thisModel as Variables
			// 4) Add text boxes to thisModel as Annotations
			for (int i = 0; i < modelNodes.size(); i++) {
				String thisNodeID = modelNodes.get(i);
				Node thisNode = nodeList.get(thisNodeID);
				System.out.println("Child Node " + i + ": " + thisNodeID);
				System.out.println("Node Type: " + thisNode.nodeType);

				if (thisNode.nodeType.equals("submodel")) {
					submodelList.put(thisNodeID, thisModel.addSubmodel(new Submodel(buildModelFromNodes(thisNodeID, thisNode.subnodes, thisNode.properties))));
				} else if (thisNode.nodeType.equals("compartment")) {
					System.out.println("Adding stock to model");
					String stockName = textValue(thisNode.properties.get("name"));
					String stockState = "";
					String stockUnits = "";
					stockList.put(thisNodeID, thisModel.addStock(new Stock(stockName, stockState, stockUnits)));
				} else if (thisNode.nodeType.equals("variable") || thisNode.nodeType.equals("condition")) {
					System.out.println("Adding variable to model");
					String varName = textValue(thisNode.properties.get("name"));
					// TODO store the formula tree into some wrapper that facilitates translation
					String varValue = textValue(thisNode.properties.get("value"));
					String varUnits = textValue(thisNode.properties.get("units"));
					String varMinVal = textValue(thisNode.properties.get("min_val"));
					String varMaxVal = textValue(thisNode.properties.get("max_val"));
					String varComment = textValue(thisNode.properties.get("comment"));
					variableList.put(thisNodeID, thisModel.addVariable(new Variable(varName, varValue, varUnits, varMinVal, varMaxVal, varComment)));
				} else if (thisNode.nodeType.equals("text")) {
					System.out.println("Adding annotation to model");
					thisModel.addAnnotation(textValue(thisNode.properties.get("name")));
				} else {
					System.out.println("Skipping useless node " + thisNodeID + " of type " + thisNode.nodeType);
				}
			}

			return thisModel;
		}

		private void addArcsToModel() {
			// First add the flows so we don't have any weirdnesses with the influences later
			System.out.println("Adding the flows to the model...");
			for (Enumeration<String> keys = arcList.keys(); keys.hasMoreElements();) {
				String thisArcID = keys.nextElement();
				Arc thisArc = arcList.get(thisArcID);
				System.out.println("Found " + thisArcID + " of type " + thisArc.arcType);

				if (thisArc.arcType.equals("flow")) {
					System.out.println("Adding flow to model");

					// Find the Model it belongs in by checking which Model
					// its source|destination is in (if one is a cloud, it will
					// not exist at all, so you must check both until you find one
					// that is a Stock).
					Model thisModel = null;
					Stock thisSource = null;
					Stock thisDestination = null;

					if (stockList.containsKey(thisArc.sourceID)) {
						// This is an outflow
						System.out.println("Its source is a stock.");
						thisSource = stockList.get(thisArc.sourceID);
						thisModel = (Model) thisSource.getGraph();
					}

					if (stockList.containsKey(thisArc.destinationID)) {
						// This is an inflow
						System.out.println("Its destination is a stock.");
						thisDestination = stockList.get(thisArc.destinationID);
						if (thisModel == null) {
							thisModel = (Model) thisDestination.getGraph();
						}
					}

					if (thisModel instanceof Model) {
						// Lookup the known properties for the Flow and add it to
						// the appropriate Model
						String flowName = thisArc.properties.get("name").toString();
						String flowRate = "";
						String flowUnits = "";

						System.out.println("Adding this Flow to Model " + thisModel.getName());
						Flow thisFlow = thisModel.addFlow(new Flow(flowName, flowRate, flowUnits));
						flowList.put(thisArcID, thisFlow);
						if (thisSource instanceof Stock) {
							System.out.println("Adding FlowEdge from " + thisArc.sourceID + " to the Flow");
							thisModel.addFlowEdge(new FlowEdge(thisSource, thisFlow));
						}
						if (thisDestination instanceof Stock) {
							System.out.println("Adding FlowEdge from the Flow to " + thisArc.destinationID);
							thisModel.addFlowEdge(new FlowEdge(thisFlow, thisDestination));
						}
					}
				}
			}

			// Now that all the Flows are in the Models, you can deal with the influences.
			// We begin in this loop by transforming function -> object arcs, such that
			// the function becomes a property of the object.
			System.out.println("Mapping functions to model elements...");
			for (Enumeration<String> keys = arcList.keys(); keys.hasMoreElements();) {
				String thisArcID = keys.nextElement();
				Arc thisArc = arcList.get(thisArcID);
				System.out.println("Found " + thisArcID + " of type " + thisArc.arcType);

				if (thisArc.arcType.equals("influence")) {
					// In order to uniquely determine the purpose of this arc,
					// we need to determine the node/arc types of its source and destination.
					String mySourceType = "unknown";
					if (thisArc.sourceID.contains("node")) {
						mySourceType = nodeList.get(thisArc.sourceID).nodeType;
					} else if (thisArc.sourceID.contains("arc")) {
						mySourceType = arcList.get(thisArc.sourceID).arcType;
					} else {
						System.out.println("Mysterious influence arc " + thisArcID + " connects to something that is neither an arc nor a node.");
					}

					String myDestinationType = "unknown";
					if (thisArc.destinationID.contains("node")) {
						myDestinationType = nodeList.get(thisArc.destinationID).nodeType;
					} else if (thisArc.destinationID.contains("arc")) {
						myDestinationType = arcList.get(thisArc.destinationID).arcType;
					} else {
						System.out.println("Mysterious influence arc " + thisArcID + " connects to something that is neither an arc nor a node.");
					}

					System.out.println("Type: " + mySourceType + " -> " + myDestinationType);

					// Use the node types to determine how to respond to this arc statement
					if (mySourceType.equals("function")) {
						// Get the properties of the function node that we want to use
						Node myFunction = nodeList.get(thisArc.sourceID);
						String value =   textValue(myFunction.properties.get("value"));
						String units =   textValue(myFunction.properties.get("units"));
						String minVal =  textValue(myFunction.properties.get("min_val"));
						String maxVal =  textValue(myFunction.properties.get("max_val"));
						String comment = textValue(myFunction.properties.get("comment"));

						// We want to set these values as the state/rate/value/
						// units/minVal/maxVal/comment properties
						// of the corresponding Stock, Flow, or Variable object.
						// Add a note in the source object's properties that
						// points to the object whose function it represents.
						if (myDestinationType.equals("compartment")) {
							Stock myStock = stockList.get(thisArc.destinationID);
							myStock.setState(value);
							myStock.setUnits(units);
							myStock.setMinVal(minVal);
							myStock.setMaxVal(maxVal);
							myStock.setComment(comment);
							myFunction.properties.put("function_owner", myStock);
						} else if (myDestinationType.equals("flow")) {
							Flow myFlow = flowList.get(thisArc.destinationID);
							myFlow.setRate(value);
							myFlow.setUnits(units);
							myFlow.setMinVal(minVal);
							myFlow.setMaxVal(maxVal);
							myFlow.setComment(comment);
							myFunction.properties.put("function_owner", myFlow);
						} else if (myDestinationType.equals("variable") || myDestinationType.equals("condition")) {
							Variable myVariable = variableList.get(thisArc.destinationID);
							myVariable.setValue(value);
							myVariable.setUnits(units);
							myVariable.setMinVal(minVal);
							myVariable.setMaxVal(maxVal);
							myVariable.setComment(comment);
							myFunction.properties.put("function_owner", myVariable);
						} else {
							System.out.println("Mysterious function->object arc " + thisArcID + " connects to something that is not a Stock, Flow, or Variable.");
						}
					}
				}
			}

			// Now you've finished with the function -> object mappings, so you can add the influence lines.
			// Influences represent one of these model elements:
			// 1) [function property] Function -> Stock/Flow/Variable (properties.get("complete") is not set)
			// 2) [influence line] Variable/Stock/Flow -> Function (properties.get("complete") is set)
			// 3) [ghost] Variable -> Variable (Real -> Ghost) (properties.get("complete") is not set) (display properties exist)
			//    Note: Ghost variables have functions
			//			and can have multiple influence lines into/out of them
			//			Flag them as ghosts, don't create the edge, and collapse them
			//			in a final pass.
			// 4) [variable->dot link - internal exiting variable] Variable -> Variable (Real -> Dot) (properties.get("complete") is set) (display properties don't exist)
			//    Note: the dot variable belongs to the submodel it is internal to.
			//          Dot variables do not have functions
			//			They should only have one input
			//			They should be removed from the model they exist in
			// 5) [dot->variable link - internal entering variable - dependency] Variable -> Function (variable's properties.get("complete") is not set)
			//    Note: dependency variables should have no entering edges,
			//			are related to the second arc in a link pair,
			//			and belong to the model that they feed into (this is good)
			//			The dot variable should be removed from the model it exists in
			//			The function's variable should be flagged as a dependency in the model
			// 6) [submodel->variable link - external variable - dependency] Submodel -> Function
			//    Note: this dependency belongs to the function-containing model
			//			Its variable should be flagged
			// 7) [variable->submodel link - external variable] Variable -> Submodel
			//    Note: Simply skip over these statements.
			//          This is a provision rather than a dependency, but you don't
			//          have to remove the submodel element because it doesn't exist in
			//          any model.
			// 8) [submodel->submodel link - variable to variable in parent model] Submodel -> Submodel
			//    Note: This statement has no meaning in the separate models context.
			//          Simply skip over these arcs.
			System.out.println("Adding the influence lines, ghosts, and links...");
			for (Enumeration<String> keys = arcList.keys(); keys.hasMoreElements();) {
				String thisArcID = keys.nextElement();
				Arc thisArc = arcList.get(thisArcID);
				System.out.println("Found " + thisArcID + " of type " + thisArc.arcType);

				if (thisArc.arcType.equals("influence")) {
					// In order to uniquely determine the purpose of this arc,
					// we need to determine the node/arc types of its source and destination.
					String mySourceType = "unknown";
					if (thisArc.sourceID.contains("node")) {
						mySourceType = nodeList.get(thisArc.sourceID).nodeType;
					} else if (thisArc.sourceID.contains("arc")) {
						mySourceType = arcList.get(thisArc.sourceID).arcType;
					} else {
						System.out.println("Mysterious influence arc " + thisArcID + " connects to something that is neither an arc nor a node.");
					}

					String myDestinationType = "unknown";
					if (thisArc.destinationID.contains("node")) {
						myDestinationType = nodeList.get(thisArc.destinationID).nodeType;
					} else if (thisArc.destinationID.contains("arc")) {
						myDestinationType = arcList.get(thisArc.destinationID).arcType;
					} else {
						System.out.println("Mysterious influence arc " + thisArcID + " connects to something that is neither an arc nor a node.");
					}

					System.out.println("Type: " + mySourceType + " -> " + myDestinationType);

					// Use the node types to determine how to respond to this arc statement
					if (myDestinationType.equals("function")) {
						System.out.println("A");
						SimpleDirectedSparseVertex myTargetModelElement = (SimpleDirectedSparseVertex) nodeList.get(thisArc.destinationID).properties.get("function_owner");
						if (mySourceType.equals("compartment")) {
							System.out.println("B");
							// Influence line from a Stock to another element
							// Create an InfluenceEdge from the Stock to the function's object
							Stock myStock = stockList.get(thisArc.sourceID);
							Model thisModel = (Model) myStock.getGraph();
							System.out.println("[" + (myStock.inDegree() + myStock.outDegree()) + ":" + (myTargetModelElement.inDegree() + myTargetModelElement.outDegree()) + "](" + myStock.getClass() + " => " + myTargetModelElement.getClass());
							InfluenceEdge ie = new InfluenceEdge(myStock, myTargetModelElement);
							try {
								thisModel.addInfluenceEdge(ie);
							} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
								if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), ie).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
									System.out.println("Encountered a parallel edge from " + myStock.getName() + " to " + ((Flow) myTargetModelElement).getName() + ".  Skipping over this one.");
								} else {
									System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING INFLUENCE EDGE!");
								}
							}
						} else if (mySourceType.equals("flow")) {
							System.out.println("C");
							// Influence line from a Flow to another element
							// Create an InfluenceEdge from the Flow to the function's object
							Flow myFlow = flowList.get(thisArc.sourceID);
							Model thisModel = (Model) myFlow.getGraph();
							System.out.println("[" + (myFlow.inDegree() + myFlow.outDegree()) + ":" + (myTargetModelElement.inDegree() + myTargetModelElement.outDegree()) + "](" + myFlow.getClass() + " => " + myTargetModelElement.getClass());
							InfluenceEdge ie = new InfluenceEdge(myFlow, myTargetModelElement);
							try {
								thisModel.addInfluenceEdge(ie);
							} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
								if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), ie).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
									System.out.println("Encountered a parallel edge from " + myFlow.getName() + " to " + ((Flow) myTargetModelElement).getName() + ".  Skipping over this one.");
								} else {
									System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING INFLUENCE EDGE!");
								}
							}
						} else if (mySourceType.equals("variable") || mySourceType.equals("condition")) {
							System.out.println("D");
							Node mySource = nodeList.get(thisArc.sourceID);
							if (mySource.properties.containsKey("complete")) {
								// Influence line from a Variable/Condition to another element
								// Create an InfluenceEdge from the Variable to the function's object
								Variable myVariable = variableList.get(thisArc.sourceID);
								Model thisModel = (Model) myVariable.getGraph();
								System.out.println("[" + (myVariable.inDegree() + myVariable.outDegree()) + ":" + (myTargetModelElement.inDegree() + myTargetModelElement.outDegree()) + "](" + myVariable.getClass() + " => " + myTargetModelElement.getClass());
								InfluenceEdge ie = new InfluenceEdge(myVariable, myTargetModelElement);
								try {
									thisModel.addInfluenceEdge(ie);
								} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
									if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), ie).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
										System.out.println("Encountered a parallel edge from " + myVariable.getName() + " to " + ((Flow) myTargetModelElement).getName() + ".  Skipping over this one.");
									} else {
										System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING INFLUENCE EDGE!");
									}
								}
							} else {
								// Submodel internal link from "Dot Variable" to another element
								// Delete the "Dot Variable" and flag the target element as a dependency
								Variable myVariable = variableList.get(thisArc.sourceID);
								Model thisModel = (Model) myVariable.getGraph();
								if (thisModel instanceof Model) {
									System.out.print("Removing variable " + myVariable.getName() + "...");
									thisModel.removeVariable(myVariable);
									System.out.println("done");
									thisModel.addDependency(myTargetModelElement);
								}
							}
						} else if (mySourceType.equals("submodel")) {
							System.out.println("E");
							// Submodel to external element link
							// Add a SubmodelEdge from the Submodel to the other element in the containing Model
							// Maintain a reference in the SubmodelEdge to the Submodel's internal element from which the link originated
							Submodel mySubmodel = submodelList.get(thisArc.sourceID);
							Model thisModel = (Model) mySubmodel.getGraph();
							Links mySubmodelLinks = linksList.get(thisArc.sourceID);

							for (Enumeration<String> linksKeys = mySubmodelLinks.arcPairs.keys(); linksKeys.hasMoreElements();) {
								String thisSourceArcID = linksKeys.nextElement();
								String thisDestinationArcID = textValue(mySubmodelLinks.arcPairs.get(thisSourceArcID));

								if (thisDestinationArcID.equals(thisArcID)) {
									SimpleDirectedSparseVertex mySourceElement = new SimpleDirectedSparseVertex();
									String sourceElementID = arcList.get(thisSourceArcID).sourceID;
									if (sourceElementID.contains("node")) {
										String nodeType = nodeList.get(sourceElementID).nodeType;
										if (nodeType.equals("compartment")) {
											mySourceElement = stockList.get(sourceElementID);
										} else if (nodeType.equals("variable") || nodeType.equals("condition")) {
											mySourceElement = variableList.get(sourceElementID);
										} else if (nodeType.equals("submodel")) {
											mySourceElement = submodelList.get(sourceElementID);
										} else {
											System.out.println("Link originating element " + sourceElementID + " should be of type compartment/variable/condition/submodel but is of type " + nodeType);
										}
									} else if (sourceElementID.contains("arc")) {
										String arcType = arcList.get(sourceElementID).arcType;
										if (arcType.equals("flow")) {
											mySourceElement = flowList.get(sourceElementID);
										} else {
											System.out.println("Link originating element " + sourceElementID + " should be of type flow but is of type " + arcType);
										}
									}

									SubmodelEdge se = new SubmodelEdge(mySubmodel, myTargetModelElement, mySourceElement, null);
									try {
										thisModel.addSubmodelEdge(se);
									} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
										if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), se).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
											System.out.println("Encountered a parallel edge from " + mySubmodel.getModel().getName() + " to " + ((Flow) myTargetModelElement).getName() + ".  Skipping over this one.");
										} else {
											System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING SUBMODEL EDGE!");
										}
									}
									break;
								}
							}
						}
					} else if (myDestinationType.equals("submodel")) {
						System.out.println("F");
						if (mySourceType.equals("submodel")) {
							// Submodel to Submodel link
							// Add a SubmodelEdge between the two Submodels in the containing Model
							// Maintain references in the SubmodelEdge to both Submodel's internal elements which are the endpoints of the four-arc link
							Submodel mySourceSubmodel = submodelList.get(thisArc.sourceID);
							Submodel myDestinationSubmodel = submodelList.get(thisArc.destinationID);
							Model thisModel = (Model) mySourceSubmodel.getGraph();
							Links mySourceSubmodelLinks = linksList.get(thisArc.sourceID);
							Links myDestinationSubmodelLinks = linksList.get(thisArc.destinationID);

							SimpleDirectedSparseVertex mySourceElement = new SimpleDirectedSparseVertex();
							SimpleDirectedSparseVertex myDestinationElement = new SimpleDirectedSparseVertex();

							String destinationElementID = arcList.get(myDestinationSubmodelLinks.arcPairs.get(thisArcID)).destinationID;
							if (destinationElementID.contains("node") && nodeList.get(destinationElementID).nodeType.equals("function")) {
								myDestinationElement = (SimpleDirectedSparseVertex) nodeList.get(destinationElementID).properties.get("function_owner");
							} else {
								System.out.println("Link destination element " + destinationElementID + " should be of type function but is of type " + nodeList.get(destinationElementID).nodeType);
							}

							for (Enumeration<String> linksKeys = mySourceSubmodelLinks.arcPairs.keys(); linksKeys.hasMoreElements();) {
								String thisSourceArcID = linksKeys.nextElement();
								String thisDestinationArcID = mySourceSubmodelLinks.arcPairs.get(thisSourceArcID);

								if (thisDestinationArcID.equals(thisArcID)) {
									String sourceElementID = arcList.get(thisSourceArcID).sourceID;
									if (sourceElementID.contains("node")) {
										String nodeType = nodeList.get(sourceElementID).nodeType;
										if (nodeType.equals("compartment")) {
											mySourceElement = stockList.get(sourceElementID);
										} else if (nodeType.equals("variable") || nodeType.equals("condition")) {
											mySourceElement = variableList.get(sourceElementID);
										} else if (nodeType.equals("submodel")) {
											mySourceElement = submodelList.get(sourceElementID);
										} else {
											System.out.println("Link originating element " + sourceElementID + " should be of type compartment/variable/condition/submodel but is of type " + nodeType);
										}
									} else if (sourceElementID.contains("arc")) {
										String arcType = arcList.get(sourceElementID).arcType;
										if (arcType.equals("flow")) {
											mySourceElement = flowList.get(sourceElementID);
										} else {
											System.out.println("Link originating element " + sourceElementID + " should be of type flow but is of type " + arcType);
										}
									}

									SubmodelEdge se = new SubmodelEdge(mySourceSubmodel, myDestinationSubmodel, mySourceElement, myDestinationElement);
									try {
										thisModel.addSubmodelEdge(se);
									} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
										if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), se).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
											System.out.println("Encountered a parallel edge from " + mySourceSubmodel.getModel().getName() + " to " + myDestinationSubmodel.getModel().getName() + ".  Skipping over this one.");
										} else {
											System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING SUBMODEL EDGE!");
										}
									}
									break;
								}
							}
						} else if (mySourceType.equals("compartment") || mySourceType.equals("flow") || mySourceType.equals("variable") || mySourceType.equals("condition")) {
							// Element to Submodel link
							// Add a SubmodelEdge from the element to the Submodel in the containing Model
							// Maintain a reference in the SubmodelEdge to the Submodel's internal element which is the link's ultimate destination
							Submodel mySubmodel = submodelList.get(thisArc.destinationID);
							Model thisModel = (Model) mySubmodel.getGraph();
							Links mySubmodelLinks = linksList.get(thisArc.destinationID);

							SimpleDirectedSparseVertex mySourceElement = new SimpleDirectedSparseVertex();
							SimpleDirectedSparseVertex myDestinationElement = new SimpleDirectedSparseVertex();

							if (mySourceType.equals("compartment")) {
								mySourceElement = stockList.get(thisArc.sourceID);
							} else if (mySourceType.equals("flow")) {
								mySourceElement = flowList.get(thisArc.sourceID);
							} else if (mySourceType.equals("variable") || mySourceType.equals("condition")) {
								mySourceElement = variableList.get(thisArc.sourceID);
							} else if (mySourceType.equals("submodel")) {
								mySourceElement = submodelList.get(thisArc.sourceID);
							} else {
								System.out.println("Link source element " + thisArc.sourceID + " should be of type compartment/flow/variable/condition/submodel but is of type " + mySourceType);
							}

							String destinationElementID = arcList.get(mySubmodelLinks.arcPairs.get(thisArcID)).destinationID;
							if (destinationElementID.contains("node") && nodeList.get(destinationElementID).nodeType.equals("function")) {
								myDestinationElement = (SimpleDirectedSparseVertex) nodeList.get(destinationElementID).properties.get("function_owner");
							} else {
								System.out.println("Link destination element " + destinationElementID + " should be of type function but is of type " + nodeList.get(destinationElementID).nodeType);
							}

							SubmodelEdge se = new SubmodelEdge(mySourceElement, mySubmodel, null, myDestinationElement);
							try {
								thisModel.addSubmodelEdge(se);
							} catch (edu.uci.ics.jung.exceptions.ConstraintViolationException e) {
								if (edu.uci.ics.jung.utils.PredicateUtils.evaluateNestedPredicates(e.getViolatedConstraint(), se).keySet().toArray()[0] instanceof edu.uci.ics.jung.graph.predicates.ParallelEdgePredicate) {
									System.out.println("Encountered a parallel edge from " + ((Flow) mySourceElement).getName() + " to " + mySubmodel.getModel().getName() + ".  Skipping over this one.");
								} else {
									System.out.println("UNIDENTIFIED EXCEPTION WHILE CREATING SUBMODEL EDGE!");
								}
							}
						}
					} else if (mySourceType.equals(myDestinationType)) {
						System.out.println("G");
						if (thisArc.properties.containsKey("complete")) {
							System.out.println("G1");
							// Element to "Dot Variable" internal link
							// Remove the "Dot Variable" from the model containing it
							Variable myDotVariable = variableList.get(thisArc.destinationID);
							if (myDotVariable instanceof Variable) {
								System.out.println("G1a");
								Model thisModel = (Model) myDotVariable.getGraph();
								if (thisModel instanceof Model) {
									System.out.print("Removing dot variable " + myDotVariable.getName() + "...");
									thisModel.removeVariable(myDotVariable);
									System.out.println("done");
								}
							} else {
								System.out.println("G1b");
								System.out.println("Unrecognizable object -> object mapping in " + thisArcID);
							}
						} else {
							System.out.println("G2");
							// Ghosted object
							// To be safe, we should update the ghost Object to make sure
							// it has all the same information as the Object it references.
							// Then we need to flag it as a ghost element in the model.
							Hashtable<String, Object> ghostNote = new Hashtable<String, Object>();
							if (mySourceType.equals("compartment")) {
								// First making the two identical
								System.out.println("G3");
								Stock ghostedStock = stockList.get(thisArc.sourceID);
								Stock ghostStock = stockList.get(thisArc.destinationID);
								ghostStock.setState(ghostedStock.getState());
								ghostStock.setUnits(ghostedStock.getUnits());
								ghostStock.setMinVal(ghostedStock.getMinVal());
								ghostStock.setMaxVal(ghostedStock.getMaxVal());
								ghostStock.setComment(ghostedStock.getComment());
								// And now the note
								Model ghostsModel = (Model) ghostStock.getGraph();
								ghostNote.put("ghostElement", ghostStock);
								ghostNote.put("ghostedElement", ghostedStock);
								ghostNote.put("ghostedModel", (Model) ghostedStock.getGraph());
								ghostsModel.addGhostNote(ghostNote);
							} else if (mySourceType.equals("flow")) {
								System.out.println("G4");
								// First making the two identical
								Flow ghostedFlow = flowList.get(thisArc.sourceID);
								Flow ghostFlow = flowList.get(thisArc.destinationID);
								ghostFlow.setRate(ghostedFlow.getRate());
								ghostFlow.setUnits(ghostedFlow.getUnits());
								ghostFlow.setMinVal(ghostedFlow.getMinVal());
								ghostFlow.setMaxVal(ghostedFlow.getMaxVal());
								ghostFlow.setComment(ghostedFlow.getComment());
								// And now the note
								Model ghostsModel = (Model) ghostFlow.getGraph();
								ghostNote.put("ghostElement", ghostFlow);
								ghostNote.put("ghostedElement", ghostedFlow);
								ghostNote.put("ghostedModel", (Model) ghostedFlow.getGraph());
								ghostsModel.addGhostNote(ghostNote);
							} else if (mySourceType.equals("variable") || mySourceType.equals("condition")) {
								System.out.println("G5");
								// First making the two identical
								Variable ghostedVariable = variableList.get(thisArc.sourceID);
								Variable ghostVariable = variableList.get(thisArc.destinationID);
								ghostVariable.setValue(ghostedVariable.getValue());
								ghostVariable.setUnits(ghostedVariable.getUnits());
								ghostVariable.setMinVal(ghostedVariable.getMinVal());
								ghostVariable.setMaxVal(ghostedVariable.getMaxVal());
								ghostVariable.setComment(ghostedVariable.getComment());
								// And now the note
								Model ghostsModel = (Model) ghostVariable.getGraph();
								ghostNote.put("ghostElement", ghostVariable);
								ghostNote.put("ghostedElement", ghostedVariable);
								ghostNote.put("ghostedModel", (Model) ghostedVariable.getGraph());
								ghostsModel.addGhostNote(ghostNote);
							}
						}
					} else if (mySourceType.equals("function")) {
						System.out.println("H");
						// Skip these since we handled them in the last loop
					} else {
						System.out.println("Identified new arc type combination (" + mySourceType + " -> " + myDestinationType + ") at " + thisArcID);
					}
				}
			}
			System.out.println("Finished generating the models.");
		}
	}

	class KeyValuePair {
		public String key;
		public Object value;

		public KeyValuePair(String key, Object value) {
			this.key = key;
			this.value = value;
		}
	}

	abstract class SimilePrologExpression {}

	class Source extends SimilePrologExpression {
		public String program;
		public String version;
		public String edition;
		public String date;

		public Source(String program, String version, String edition, String date) {
			this.program = program;
			this.version = version;
			this.edition = edition;
			this.date = date;
		}
	}

	class Roots extends SimilePrologExpression {
		public Vector<String> subnodes;

		public Roots(Vector<String> subnodes) {
			this.subnodes = subnodes;
		}
	}

	class Properties extends SimilePrologExpression {
		public Hashtable<String, Object> properties;

		public Properties(Hashtable<String, Object> properties) {
			this.properties = properties;
		}
	}

	class Node extends SimilePrologExpression {
		public String nodeType;
		public Vector<String> subnodes;
		public Hashtable<String, Object> properties;

		public Node(String nodeType, Vector<String> subnodes, Hashtable<String, Object> properties) {
			this.nodeType = nodeType;
			this.subnodes = subnodes;
			this.properties = properties;
		}
	}

	class Links extends SimilePrologExpression {
		public Hashtable<String, String> arcPairs;

		public Links(Hashtable<String, String> arcPairs) {
			this.arcPairs = arcPairs;
		}
	}

	class Arc extends SimilePrologExpression {
		public String sourceID;
		public String destinationID;
		public String arcType;
		public Hashtable<String, Object> properties;

		public Arc(String sourceID, String destinationID, String arcType, Hashtable<String, Object> properties) {
			this.sourceID = sourceID;
			this.destinationID = destinationID;
			this.arcType = arcType;
			this.properties = properties;
		}
	}
PARSER_END(SimilePrologReader)

/* Define Tokens for the Lexer */
SKIP  : { " " }
TOKEN : { < EOL			: "\n" | "\r" | "\r\n"						> }
TOKEN : { < OPEN_PAR	: "("										> }
TOKEN : { < CLOSE_PAR	: ")"										> }
TOKEN : { < OPEN_SQR	: "["										> }
TOKEN : { < CLOSE_SQR	: "]"										> }
TOKEN : { < OPEN_CUR	: "{"										> }
TOKEN : { < CLOSE_CUR	: "}"										> }
TOKEN : { < DOT			: "."										> }
TOKEN : { < COMMA		: ","										> }
TOKEN : { < DASH		: "-"										> }
TOKEN : { < EQUALS		: "="										> }
TOKEN : { < SOURCE		: "source"									> }
TOKEN : { < ROOTS		: "roots"									> }
TOKEN : { < PROPERTIES	: "properties"								> }
TOKEN : { < NODE		: "node"									> }
TOKEN : { < ARC			: "arc"										> }
TOKEN : { < LINKS		: "links"									> }
TOKEN : { < REFERENCES	: "references"								> }
TOKEN : { < IF			: "if"										> }
TOKEN : { < THEN		: "then"									> }
TOKEN : { < ELSEIF		: "elseif"									> }
TOKEN : { < ELSE		: "else"									> }
TOKEN : { < QTDSTRING	: "'" ((~["'"])|("\\""'"))* "'"				> }
TOKEN : { < MATHSYM		: ["+","*","/","^"]							> }
TOKEN : { < RELSYM		: "<" | ">" | "<=" | ">=" | "==" | "!=" | "&&" | "||" | "!"	| "and" | "or" | "not" > }
TOKEN : { < WORD		: <LETTERS> (<DIGITS> ("_" <DIGITS>)*)?		> }
TOKEN : { < #LETTERS	: (["A"-"Z","a"-"z","_"])+					> }
TOKEN : { < NUMBER		: <DIGITS> ("." <DIGITS>)? ("e" ("-")? <DIGITS>)?	> }
TOKEN : { < #DIGITS		: (["0"-"9"])+								> }

/*
 * Parser's BNF Production Rules
 *
 *   Start			->	((Expression)? EOL)* EOF
 *
 *   Expression		->	Source | Roots | Properties | Node | Arc | Links | References
 *
 *   Source			->	<SOURCE> <OPEN_PAR>
 *						<WORD> <EQUALS> <QTDSTRING> <COMMA>
 *						<WORD> <EQUALS> <NUMBER> <COMMA>
 *						<WORD> <EQUALS> <WORD> <COMMA>
 *						<WORD> <EQUALS> <QTDSTRING>
 *						<CLOSE_PAR> <DOT>
 *
 *   Roots			->	<ROOTS> <OPEN_PAR>
 *						List
 *						<CLOSE_PAR> <DOT>
 *
 *   Properties		->	<PROPERTIES> <OPEN_PAR>
 *						List
 *						<CLOSE_PAR> <DOT>
 *
 *   Node			->	<NODE> <OPEN_PAR>
 *						<WORD> <COMMA>
 *						<WORD> <COMMA>
 *						List <COMMA>
 *						List <COMMA>
 *						List
 *						<CLOSE_PAR> <DOT>
 *
 *   Arc			->	<ARC> <OPEN_PAR>
 *						<WORD> <COMMA>
 *						<WORD> <COMMA>
 *						<WORD> <COMMA>
 *						<WORD> <COMMA>
 *						List <COMMA>
 *						List
 *						<CLOSE_PAR> <DOT>
 *
 *   Links			->	<LINKS> <OPEN_PAR>
 *						<WORD> <COMMA> List
 *						<CLOSE_PAR> <DOT>
 *
 *   References		->	<REFERENCES> <OPEN_PAR>
 *						<WORD> <COMMA> List
 *						<CLOSE_PAR> <DOT>
 *
 *   List			->	<OPEN_SQR>
 *						(ListElement (<COMMA> ListElement)*)?
 *						<CLOSE_SQR>
 *
 *   ListElement	->	List
 *					  | (<DASH>)? <NUMBER>
 *					  | <WORD> (SubroutineArguments | DashValue | EqualsValue)?
					  | Formula
 *
 *   SubroutineArguments ->	<OPEN_PAR> (Formula (<COMMA> Formula)*)? <CLOSE_PAR>
 *
 *   DashValue		->	<DASH> Formula
 *
 *   EqualsValue	->	<EQUALS> Formula
 *
 *   Formula		->	Term ((<MATHSYM>|<DASH>|<RELSYM>) Term)* | <IF> Formula <THEN> Formula (<ELSEIF> Formula <THEN> Formula)* <ELSE> Formula
 *
 *   Term			->	<WORD> (SubroutineArguments)? | <NUMBER> | <QTDSTRING> | List | <DASH> Term | <OPEN_PAR> Formula <CLOSE_PAR> | <OPEN_CUR> Formula <CLOSE_CUR>
 *
 */

void Start() :
{}
{
	{ System.out.println("Starting to Read File"); }

	(
		(Expression())?
		<EOL>
	)*
	<EOF>

	{ System.out.println("Finished Reading File"); }
}

void Expression() :
{}
{
		{ System.out.println("Found Source Expression"); }
		Source()
	|
		{ System.out.println("Found Roots Expression"); }
		Roots()
	|
		{ System.out.println("Found Properties Expression"); }
		Properties()
	|
		{ System.out.println("Found Node Expression"); }
		Node()
	|
		{ System.out.println("Found Arc Expression"); }
		Arc()
	|
		{ System.out.println("Found Links Expression"); }
		Links()
	|
		{ System.out.println("Found References Expression"); }
		References()
}

void Source() :
{
	Token program, version, edition, date;
}
{
	<SOURCE>
	<OPEN_PAR>

	<WORD>
	<EQUALS>
	program = <QTDSTRING>

	<COMMA>

	<WORD>
	<EQUALS>
	version = <NUMBER>

	<COMMA>

	<WORD>
	<EQUALS>
	edition = <WORD>

	<COMMA>

	<WORD>
	<EQUALS>
	date = <QTDSTRING>

	<CLOSE_PAR>
	<DOT>

	{
		metadata.put("source",
			new Source(
				program.image.substring(1, program.image.length()-1),
				version.image,
				edition.image,
				date.image.substring(1, date.image.length()-1)
			)
		);
		Source s = (Source) metadata.get("source");
		System.out.println("Stored this metadata:");
		System.out.println("Program: " + s.program);
		System.out.println("Version: " + s.version);
		System.out.println("Edition: " + s.edition);
		System.out.println("Date: " + s.date);
	}
}

/*
 * This designates the nodes that will be present in this graph.
 * Any element not in this list will belong to a submodel of this model,
 * which we need to represent as a separate graph with the appropriate
 * links intact.
 */
void Roots() :
{
	Object subnodes;
}
{
	<ROOTS>
	<OPEN_PAR>

	// This will always be a Vector of Strings (they are nodeIDs)
	subnodes = List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(subnodes instanceof Vector)) {
			subnodes = new Vector<String>();
		}
		metadata.put("roots", new Roots((Vector<String>) subnodes));
		Roots r = (Roots) metadata.get("roots");
		System.out.println("Number of Root Nodes: " + r.subnodes.size());
	}
}

void Properties() :
{
	Object properties;
}
{
	<PROPERTIES>
	<OPEN_PAR>
	// This will always be a Hashtable of Strings to Objects
	properties = List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(properties instanceof Hashtable)) {
			properties = new Hashtable<String, Object>();
		}
		metadata.put("properties", new Properties((Hashtable<String, Object>) properties));
		Properties p = (Properties) metadata.get("properties");
		System.out.println("Name: " + p.properties.get("name"));

		for (Enumeration<String> keys = p.properties.keys(); keys.hasMoreElements();) {
			String thisProperty = keys.nextElement();
			Object thisValue = p.properties.get(thisProperty);
		}
	}
}

void Node() :
{
	Token nodeID, nodeType;
	Object subnodes, properties;
}
{
	<NODE>
	<OPEN_PAR>

	nodeID = <WORD>

	<COMMA>

	nodeType = <WORD>

	<COMMA>

	// This will always be a Vector of Strings (they are nodeIDs)
	subnodes = List()

	<COMMA>

	// This will always be a Hashtable of Strings to Objects
	properties = List()

	<COMMA>

	List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(subnodes instanceof Vector)) {
			subnodes = new Vector<String>();
		}
		if (!(properties instanceof Hashtable)) {
			properties = new Hashtable<String, Object>();
		}
		nodeList.put(nodeID.image,
			new Node(
				nodeType.image,
				(Vector<String>) subnodes,
				(Hashtable<String, Object>) properties
			)
		);
		Node n = nodeList.get(nodeID.image);
		System.out.println("Node ID: " + nodeID.image);
		System.out.println("Node Type: " + n.nodeType);
		System.out.println("Number of Subnodes: " + n.subnodes.size());
		System.out.println("Number of Properties: " + n.properties.size());
	}
}

void Arc() :
{
	Token arcID, sourceID, destinationID, arcType;
	Object properties;
}
{
	<ARC>
	<OPEN_PAR>

	arcID = <WORD>

	<COMMA>

	sourceID = <WORD>

	<COMMA>

	destinationID = <WORD>

	<COMMA>

	arcType = <WORD>

	<COMMA>

	// This will always be a Hashtable of Strings to Objects
	properties = List()

	<COMMA>

	List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(properties instanceof Hashtable)) {
			properties = new Hashtable<String, Object>();
		}
		arcList.put(arcID.image,
			new Arc(
				sourceID.image,
				destinationID.image,
				arcType.image,
				(Hashtable<String, Object>) properties
			)
		);
		Arc a = arcList.get(arcID.image);
		System.out.println("Arc ID: " + arcID.image);
		System.out.println("Source ID: " + a.sourceID);
		System.out.println("Destination ID: " + a.destinationID);
		System.out.println("Arc Type: " + a.arcType);
		System.out.println("Number of Properties: " + a.properties.size());
	}
}

void Links() :
{
	Token submodelID;
	Object arcPairs;
}
{
	<LINKS>
	<OPEN_PAR>

	submodelID = <WORD>

	<COMMA>

	// This will always be a Hashtable of Strings to Strings
	arcPairs = List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(arcPairs instanceof Hashtable)) {
			arcPairs = new Hashtable<String, String>();
		}
		linksList.put(submodelID.image, new Links((Hashtable<String, String>) arcPairs));
		Links l = linksList.get(submodelID.image);
		System.out.println("Stored a set of Links");
		System.out.println("Submodel ID: " + submodelID.image);
		System.out.println("Number of Arc Pairs: " + l.arcPairs.size());
	}
}

void References() :
{
	Token submodelID;
	Object references;
}
{
	<REFERENCES>
	<OPEN_PAR>

	submodelID = <WORD>

	<COMMA>

	// This will always be a Vector of Strings
	references = List()

	<CLOSE_PAR>
	<DOT>

	{
		if (!(references instanceof Vector)) {
			references = new Vector<String>();
		}
		// linksList.put(submodelID.image, new Links((Hashtable<String, String>) arcPairs));
		// Links l = linksList.get(submodelID.image);
		System.out.println("Stored a set of references");
		System.out.println("Submodel ID: " + submodelID.image);
		System.out.println("Number of references: " + ((Vector) references).size());
	}
}

Object List() :
{
	Object nextElement;
	Object list = new Object();
/*
 * A List will now be either:
 *
 * 1) A Hashtable<String, Object> if this is a list of KeyValuePairs
 * 2) A Vector of Objects if this is a list of Strings or Vectors
 */
}
{
	<OPEN_SQR>

	(
		nextElement = ListElement()
		{
			if (nextElement instanceof KeyValuePair) {
				list = new Hashtable<String, Object>();
				((Hashtable<String, Object>) list).put(((KeyValuePair) nextElement).key, ((KeyValuePair) nextElement).value);
			} else {
				list = new Vector<Object>();
				((Vector<Object>) list).add(nextElement);
			}
		}
		(
			<COMMA>
			nextElement = ListElement()
			{
				if (nextElement instanceof KeyValuePair) {
					((Hashtable<String, Object>) list).put(((KeyValuePair) nextElement).key, ((KeyValuePair) nextElement).value);
				} else {
					((Vector<Object>) list).add(nextElement);
				}
			}
		)*
	)?

	<CLOSE_SQR>

	{
		if (list instanceof Vector) {
			((Vector<Object>) list).trimToSize();
		}
		return list;
	}
}

Object ListElement() :
{
	Object thisElement;
	Token t;
/*
 * The different types of list elements are as follows:
 *
 * Vector List
 * Hashtable List
 * String QtdString
 * String Number
 * String Word
 * String Subroutine
 * KeyValuePair Dash-Pair
 * KeyValuePair Equals-Pair
 */
}
{
		thisElement = List()
		{ return thisElement; }
	|
		{ thisElement = ""; }
		(
			t = <DASH>
			{ thisElement = t.image; }
		)?
		t = <NUMBER>
		{
			thisElement = thisElement + t.image;
			return thisElement;
		}
	|
		t = <WORD>
		{ thisElement = t.image; }
		(
				thisElement = SubroutineArguments()
				{ thisElement = t.image + thisElement; }
			|
				thisElement = DashValue()
				{ thisElement = new KeyValuePair(t.image, thisElement); }
			|
				thisElement = EqualsValue()
				{ thisElement = new KeyValuePair(t.image, thisElement); }
		)?
		{ return thisElement; }
	|
		thisElement = Formula()
		{ return thisElement; }
}

FormulaNode SubroutineArguments() :
{
	FormulaNode theseArgs = new FormulaNode();
	FormulaNode moreCharacters;
/*
 * The arguments to a subroutine can be:
 *
 * String Number
 * String Word
 * Vector List
 * Hashtable List
 * String Subroutine
 * String Formula
 */
}
{
	<OPEN_PAR>
	{ theseArgs.formulaText += "("; }

	(
		moreCharacters = Formula()
		{ theseArgs.formulaText += moreCharacters; }
		(
			<COMMA>
			{ theseArgs.formulaText += ","; }
			moreCharacters = Formula()
			{ theseArgs.formulaText += moreCharacters; }
		)*
	)?

	<CLOSE_PAR>
	{ theseArgs.formulaText += ")"; }

	{ return theseArgs; }
}

FormulaNode DashValue() :
{
	FormulaNode thisDashValue;
/*
 * This returns either:
 *
 * Vector List
 * Hashtable List
 * String QtdString
 * String Number
 * String Word
 */
}
{
	<DASH>
	thisDashValue = Formula()
	{ return thisDashValue; }
}

FormulaNode EqualsValue() :
{
	FormulaNode thisEqualsValue;
/*
 * This returns either:
 *
 * Vector List
 * Hashtable List
 * String QtdString
 * String Number
 * String Word
 * String Formula
 * String Subroutine
 */
}
{
	<EQUALS>
	thisEqualsValue = Formula()
	{ return thisEqualsValue; }
}

FormulaNode Formula() :
{
	FormulaNode thisFormula = null;
	FormulaNode moreCharacters = null;
	Token t;
}
{
		thisFormula = Term()
		(
			(
					t = <MATHSYM>
				|
					t = <DASH>
				|
					t = <RELSYM>
			)
		 	moreCharacters = Term()
			{ thisFormula.formulaText += t.image + moreCharacters; }
		)*
		{ return thisFormula; }
	|
		<IF>
		moreCharacters = Formula()
		{ thisFormula.formulaText = "if " + moreCharacters; }
		<THEN>
		moreCharacters = Formula()
		{ thisFormula.formulaText += " then " + moreCharacters; }
		(
			<ELSEIF>
			moreCharacters = Formula()
			{ thisFormula.formulaText += " elseif " + moreCharacters; }
			<THEN>
			moreCharacters = Formula()
			{ thisFormula.formulaText += " then " + moreCharacters; }
		)*
		<ELSE>
		moreCharacters = Formula()
		{ thisFormula.formulaText += " else " + moreCharacters; }
		{ return thisFormula; }
}

FormulaNode Term() :
{
	FormulaNode thisTerm = null;
	FormulaNode moreCharacters = null;
	Object thisList;
	Token t;
}
{
		t = <WORD>
		{ thisTerm = new FormulaNode(); thisTerm.nodeType = FormulaNode.NodeType.FUNCTION; thisTerm.literal = t.image; }
		(
			moreCharacters = SubroutineArguments()
			{ thisTerm.formulaText += moreCharacters; }
		)?
		{ return thisTerm; }
	|
		t = <NUMBER>
		{
			thisTerm = new FormulaNode();
			thisTerm.nodeType = FormulaNode.NodeType.NUMBERLITERAL;
			thisTerm.literal = t.image;
			
			thisTerm.formulaText = t.image;
			return thisTerm;
		}
	|
		t = <QTDSTRING>
		{
			thisTerm = new FormulaNode();
			thisTerm.nodeType = FormulaNode.NodeType.STRINGLITERAL;
			thisTerm.formulaText = t.image.substring(1, t.image.length()-1);
			thisTerm.literal = thisTerm.formulaText;

			return thisTerm;
		}
	|
		thisList = List()
		{
			// list is a literal for now, to be fixed later
			thisTerm = new FormulaNode();
			thisTerm.nodeType = FormulaNode.NodeType.LIST;
			thisTerm.formulaText = thisList.toString();
			thisTerm.literal = thisTerm.formulaText;

			return thisTerm;
		}
	|
		<DASH>
		moreCharacters = Term()
		{
			thisTerm = new FormulaNode();
			thisTerm.nodeType = FormulaNode.NodeType.OPERATOR;
			thisTerm.operator = "-";
			thisTerm.add(moreCharacters);
			
			thisTerm.formulaText = "-" + moreCharacters;
			return thisTerm;
		}
	|
		<OPEN_PAR>
		moreCharacters = Formula()
		<CLOSE_PAR>
		{
			thisTerm = new FormulaNode();
			thisTerm.nodeType = FormulaNode.NodeType.EXPRESSION;
			thisTerm.add(moreCharacters);

			thisTerm.formulaText = "(" + moreCharacters + ")";
			return thisTerm;
		}
	|
		<OPEN_CUR>
		moreCharacters = Formula()
		<CLOSE_CUR>
		{
			// TODO
			thisTerm.formulaText = "{" + moreCharacters + "}";
			return thisTerm;
		}
}
