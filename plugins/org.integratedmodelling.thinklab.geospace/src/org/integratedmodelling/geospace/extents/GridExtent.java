/**
 * CellExtent.java
 * ----------------------------------------------------------------------------------
 * 
 * Copyright (C) 2008 www.integratedmodelling.org
 * Created: Feb 18, 2008
 *
 * ----------------------------------------------------------------------------------
 * This file is part of ThinklabGeospacePlugin.
 * 
 * ThinklabGeospacePlugin is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ThinklabGeospacePlugin is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with the software; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 * 
 * ----------------------------------------------------------------------------------
 * 
 * @copyright 2008 www.integratedmodelling.org
 * @author    Ferdinando Villa (fvilla@uvm.edu)
 * @date      Feb 18, 2008
 * @license   http://www.gnu.org/licenses/gpl.txt GNU General Public License v3
 * @link      http://www.integratedmodelling.org
 **/
package org.integratedmodelling.geospace.extents;

import org.geotools.coverage.grid.GeneralGridEnvelope;
import org.geotools.geometry.jts.ReferencedEnvelope;
import org.integratedmodelling.geospace.Geospace;
import org.integratedmodelling.geospace.coverage.RasterActivationLayer;
import org.integratedmodelling.geospace.implementations.cmodels.SubdividedCoverageConceptualModel;
import org.integratedmodelling.geospace.literals.ShapeValue;
import org.integratedmodelling.thinklab.exception.ThinklabException;
import org.integratedmodelling.thinklab.exception.ThinklabValidationException;
import org.integratedmodelling.thinklab.interfaces.knowledge.IConceptualizable;
import org.integratedmodelling.thinklab.interfaces.literals.IValue;
import org.integratedmodelling.utils.Pair;
import org.integratedmodelling.utils.Polylist;
import org.opengis.coverage.grid.GridEnvelope;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import com.vividsolutions.jts.geom.Envelope;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.geom.GeometryFactory;

/**
 * Cell extents are the extents generated by the Raster conceptual models. Vector
 * CMs should be prepared to deal with them too.
 * 
 * @author Ferdinando
 *
 */
public class GridExtent extends ArealExtent implements IConceptualizable {

	GeometryFactory gFactory = null;
	int xDivs = 0;
	int yDivs = 0;
	double cellLength = 0.0;
	double cellHeight = 0.0;
	double xOrigin = 0.0;
	double yOrigin = 0.0;
	RasterActivationLayer activationLayer = null;
	
	Geometry boundary = null;

	public GridExtent(
				SubdividedCoverageConceptualModel cm, 
				CoordinateReferenceSystem crs, 
				double x1, 
				double y1, 
				double x2,
				double y2,
				int xDivs, 
				int yDivs) {
		
		super(cm, crs, new Envelope(x1,x2,y1,y2));
		
		this.xOrigin = x1;
		this.yOrigin = y1;

		setResolution(xDivs, yDivs);
	}

	public GridExtent(SubdividedCoverageConceptualModel cm, GridExtent gridExtent) {
		super(cm, gridExtent.getCRS(), gridExtent.getEnvelope());
		
		this.xOrigin = gridExtent.getEast();
		this.yOrigin = gridExtent.getSouth();
		
		this.setResolution(gridExtent.getXCells(), gridExtent.getYCells());
	}

	public void setResolution(int xDivs, int yDivs) {

		this.xDivs = xDivs;
		this.yDivs = yDivs;
		cellLength = getEnvelope().getWidth() / xDivs;
		cellHeight = getEnvelope().getHeight() / yDivs;
	}
	
	/**
	 * return the envelope of the cell at x,y, irrespective of the activation layer
	 */
	public ReferencedEnvelope getCellEnvelope(int x, int y) {
		
		double x1 = xOrigin + (cellLength * x);
		double y1 = yOrigin + (cellHeight * y);
		double x2 = x1 + cellLength;
		double y2 = y1 + cellHeight;
		
		return new ReferencedEnvelope(x1,x2,y1,y2, getCRS());
	}
	
	/* return the area of each cell, in whatever coordinates we have. This is a regular grid, so no parameters passed. */
	public double getCellArea() {
		
		Envelope env = getCellEnvelope(0,0);
		return env.getHeight() * env.getWidth();
	}
	
	public String toString() {
		return "<" + xDivs + "," + yDivs + ">@" + envelope; 
	}
	
	public IValue getFullExtentValue() {
		return new ShapeValue(boundary);
	}

	public IValue getState(int granule) throws ThinklabException {

		/* 
		 * determine coordinates of granule. This should not get called if the activation layer
		 * is null, so no check for now. 
		 */
		Pair<Integer, Integer> xy = activationLayer.getCell(granule);
		
		/*
		 * TODO reimplement to use nextCell on activation layer. Must enforce sequential access
		 * to use effectively. 
		 */
		
		double x1 = xOrigin + (cellLength * xy.getFirst());
		double y1 = yOrigin + (cellHeight * xy.getSecond());
		double x2 = x1 + cellLength;
		double y2 = y1 + cellHeight;
		
		return new ShapeValue(x1, y1, x2, y2);
	}

	public int getTotalGranularity() {
		
		return 
			activationLayer == null ?
				(xDivs * yDivs) :
				activationLayer.totalActiveCells();
	}

	public Geometry getBoundary() {
		return 
			boundary == null ? 
				ShapeValue.makeCell(envelope.getMinX(), envelope.getMinY(), envelope.getMaxX(), envelope.getMaxY()) : 
				boundary;
	}

	public int getXCells() {
		return xDivs;
	}

	public int getYCells() {
		return yDivs;
	}

	public int getXMaxCell() {
		return xDivs;
	}

	public int getXMinCell() {
		return 0;
	}

	public int getYMinCell() {
		return 0;
	}

	public int getYMaxCell() {
		return yDivs;
	}

	public GridEnvelope getGridRange() {
		
		return new GeneralGridEnvelope( new int[] {0,0}, new int[] {xDivs, yDivs}, false);
	}

	public RasterActivationLayer getActivationLayer() throws ThinklabValidationException {
		
		if (activationLayer == null) {
			throw new ThinklabValidationException("no activation layer in grid extent");
		}
		
		return activationLayer;
	}
	
	
	public RasterActivationLayer requireActivationLayer(boolean active) {
		
		if (activationLayer == null) {
			activationLayer = new RasterActivationLayer(xDivs, yDivs, active);
		}
		
		return activationLayer;
	}
	
	/**
	 * Use the passed shape as a mask. 
	 * 
	 * @param shape
	 */
	public void mask(ShapeValue shape) {
		
		/*
		 * TODO rasterize shape on 1-bit layer with extent, res
		 */
		
		/*
		 * TODO build bitset[s] from rasterized layer
		 */
	}

	public double getNSResolution() {
		return cellHeight;
	}

	public double getEWResolution() {
		return cellLength;
	}

	@Override
	public Polylist conceptualize() throws ThinklabException {

		return Polylist.list(
				Geospace.RASTER_GRID,
				Polylist.list(Geospace.X_RANGE_OFFSET, ""+getXMinCell()),
				Polylist.list(Geospace.X_RANGE_MAX, ""+getXMaxCell()),
				Polylist.list(Geospace.Y_RANGE_OFFSET, ""+getYMinCell()),
				Polylist.list(Geospace.Y_RANGE_MAX, ""+getYMaxCell()),
				Polylist.list(Geospace.LAT_LOWER_BOUND, ""+getSouth()),
				Polylist.list(Geospace.LON_LOWER_BOUND, ""+getWest()),
				Polylist.list(Geospace.LAT_UPPER_BOUND, ""+getNorth()),
				Polylist.list(Geospace.LON_UPPER_BOUND, ""+getEast()),
				Polylist.list(Geospace.CRS_CODE, 
						Geospace.getCRSIdentifier(getCRS(), false)));
	}

}
